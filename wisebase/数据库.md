# 数据库

## 事务

事务由一个或多个sql语句组成一个整体，如果所有的语句执行成功那么修改将会全部生效，如有一条语句失败，那么该事务被成功执行的sql语句会被撤销，只有在该事务中所有的语句全部执行成功的情况下，修改的数据才会被提交到数据库。

**事务的特性**：ACID

- 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

- 一致性（Consistency）：一个事务执行之前和执行之后都必须处于一致性状态。比如，假设账户A和账户B两者一共有100块，不管A和B之间如何转账，转账几次，事务结束之后两个用户的钱相加起来应该还的是100。能量守恒定律。

- 隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，某个事务不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

- 持久性（Durability）：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。MySQL中会保存有相应的操作日志，即使遭遇故障依然能够通过日志回复最后一次更新。

**隔离级别**

用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离别一般是支持更高的并发处理，并拥有更低的系统开销。

- Read Uncommitted（读取未提交读）
读取未提交的数据，也被称为脏读。所有的事务都可以看到其它未提交事务的执行的结果。很少用于实际应用。事务A查询X的值未返回之前，事务B修改了X，事务A获得了非最新的实际值。

- Read Committed（读取提交内容）
满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。这种隔离级别也支持所谓的不可重复读，因为同一个事务的其他实例在该实例处理期间可能会有新的Commit，所以同一个select可能返回不同的结果。比如，事务A的两次查询X之间，事务B更新了X的值，那么事务A的两次查询结果将会不同。

- Repeatable Read（可重读）
MySQL默认事务隔离级别，它确保同一个事务的多个实例在并发读取数据的时候，会看到同样数据行。产生了一个棘手的问题：幻读。幻读是指当事务不是独立执行时发生的一种现象。比如，事务A修改了全表的数据行，同时事务B向表插入新一行数据。那么以后处理事务A的用户发现表中还有未修改的数据行。
通过存储引擎的多版本并发控制间隙锁机制解决了该问题。多版本并发控制只是解决了不可重复读的问题，而加上间隙锁（控制并发控制）才解决了幻读。

- Seriablizable（可串行化）
在每个读的数据行上加上共享锁，在这个最高级别的隔离级别上，可能导致大量的超时现象和锁竞争。

MVVC是为了减少加锁而引入，从而来提高并发性。MVVC只工作在repeatable readl和read commit两个隔离级别。而read uncommited每次只管读取最新版本的数据行，seriableable则会对每个读操作加锁，所以不需要MVCC。

## 索引

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。

#### B-树索引

![](https://github.com/CyC2018/InterviewNotes/raw/master/pics//5ed71283-a070-4b21-85ae-f2cbfd6ba6e1.jpg) 

为了描述B-Tree，首先定义一条数据记录为一个二元组[Key, data]，key为记录的键，data为数据记录除key外的数据。

**特性：**
1. 所有叶子节点都具有相同的深度，也就是说B-Tree是平衡的
2. 一个节点中的key从左到右非递减排列 

在B-Tree中按key检索数据的算法非常直观，首先从根节点进行二分查找，如果找到则返回对应节点的data，否则回溯递归搜索进行查找。

由于插入删除新的数据记录会破坏B-Tree性质，因此在插入删除时，需要对树进行分裂、合并的、转移等操作以保持B-Tree性质。

#### B+树索引

B+树非叶节点存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。
所有的叶节点在同一层，包含了全部关键码和相应的数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。

![](https://images2015.cnblogs.com/blog/1048139/201704/1048139-20170408134632082-1550342422.png) 

**特性：**
1. 所有关键字都出现在叶子节点的链表中，且链表中的关键字是有序的。
2. 不可能在非叶子节点命中。
3. 非叶子节点相当于是叶子节点的索引
4. 更适合做文件索引系统

在B+树的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是提高区间的访问速度。

两种搜索方式：一种是从根节点到叶节点搜索，另一种是按叶节点自己拉起的链表顺序搜索。

#### 为什么使用B-/+ Tree

红黑树等数据结构也可以用来实现索引，但是文件系统及数据库普遍采用B-/+ Tree作为索引结构。

页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续大小相等的块，每个存储块称为页（大小通常为4K），主存和磁盘以页为单位交换数据。

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘中。为了减少磁盘的I/O，磁盘往往不是严格按需读取，而是每次都会预读。这样是因为局部性原理：当一个数据被用到时，其附近的数据也通常马上会被使用。将一个节点的大小设为一页，这样每个节点只需要一次I/O就可以完全载入。B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），查找复杂度为O(h) = O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。而红黑树这种数据结构，树的明显要深得多。并且由于逻辑上很近的节点（父子）物理上可能会很远，无法利用局部性，效率明显比B-Tree差很多。

B+Tree更适合外存索引，原因和内节点的出度d有关，由于B+Tree内节点丢掉了data域，因此拥有更大的出度，拥有更好的性能，查找时间更均匀。

#### B-/+ Tree索引性质

适用于全键值、键值范围或者最左前缀的查找。适用于如下类型的查询：

```
	CREATE TABLE People(
		last_name varchar(50) not null,
		first_name varchar(50) not null,
		dob date not null,
		age int not null,
		gender enum('m', 'f') not null,
		key(last_name, first_name, dob)	
	);
```

**全值匹配：**查询和索引中的所有列进行匹配，例如查找名字为 Cuba Allen，出生于1960-01-01的人

**匹配最左前缀：**查询last_name为Allen的人，即匹配索引的第一列

**匹配列前缀：**匹配某一列的值的开头部分，使用索引的第一列，查询last_name以A为开头的人，然而却不能使用以Z为结尾的人

**精确匹配某一列并范围匹配另一列：**例如，查询last_name为全匹配，而first_name为范围匹配

**只访问索引的查询**：“覆盖索引”，即查询只需要访问索引，而无须访问数据行。

除了用于查找，还可以用于排序Order By和分组 Group By。

#### 限制

以下SQL语句无法使用索引直接查询

**如果不是按照索引的最左列开始查找，则无法使用索引：**

```
	mysql> select * from table where first_name = 'aaa';
	mysql> select * from table where dob = '1999-9-9';
```

**不能跳过索引中的列：**

```
	mysql> select * from table where last_name = 'aaa' and age=26;
```

**如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找：**

```
	mysql> select * from table 
			where last_name = 'aaa' AND first_name LIKE '%b' AND age = 26;
```

这个查询只能使用索引的前两列，索引age并没有被用上

#### 哈希索引

基于哈希表的实现，优点是查找非常快。

在MySQL中只有Memory引擎中显式支持哈希索引。

InnoDB引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常
频繁，会在B-Tree索引上再创建一个哈希索引，这样可以让B-Tree索引具有哈希索引的一些优点，比如快速的哈希查找。

**限制**：哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
只支持精确查找，由于索引数据不是按索引值排序，所以无法用于排序；
只支持等值比较查询，无法用于范围查询；
无法用于部分索引列匹配查找；
哈希索引冲突，使用链表方式解决

#### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。

使用 MATCH AGAINST，而不是普通的 WHERE。

#### 高性能的索引策略

**索引优点：**
- 大大减少服务器需要扫描的数量
- 帮助服务器避免进行排序和创建临时表
- 将随机I/O变为顺序I/O

**独立的列**
在进行查询的时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用actor_id列的索引：

```
	SELECT actor_id FROM table WHERE actor_id + 1 = 5;
```

**前缀索引**
对于索引很长的字符列，这会让索引变得大并且慢。使用前缀索引，只索引开始的部分字符。
对于前缀长度的选取需要根据 索引选择性 来确定：不重复的索引值和记录总长度的比值。选择性越高，查询效率越高。最大值为1，此时每个记录都有唯一的索引与之相对应。

```
	mysql> SELECT count(*) AS cnt, LEFT(last_name, 3) AS pref
			FROM table GROUP BY pref;
```

**多列索引**
在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句，最好把索引设置为多列索引。

```
	mysql> CREATE TABLE t(
			last_name varchar(10),
			age int,
			index(last_name),
			index(age)
			);
	mysql> SELECT * FROM t
			WHERE last_name='aaa' OR age = 1; 
```

**索引列的顺序**
让选择性强的索引列放在前面，比如name的选择性比sexy更高，因此最好把name列放在多列索引的前面

**聚蔟索引**
![](https://github.com/CyC2018/InterviewNotes/raw/master/pics//b9e9ae8c-e216-4c01-b267-a50dbeb98fa4.jpg) 

聚蔟索引并不是一种索引类型，而是一种数据存储方式。
术语“聚蔟”表示数据行和相邻的键值紧密地存储在一起，InnoDB的聚蔟索引的数据行放在B-Tree的叶子页中。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚蔟索引。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB使用一个非空索引来替代。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚蔟索引。

优点：

- 可以把相关的数据放在一起，减少I/O操作；
- 因为数据保存在B-Tree中，因此数据访问更快。

缺点：

- 聚蔟索引最大限度地提高了I/O密集型应用的性能，但是如果数据全部放在内存，就没有必要用聚蔟索引
- 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的
- 更新操作代价很高，因为每个更新的行都会被移动到新位置
- 插入到某个已满的页，会导致页分裂，使得表占用更多的磁盘空间
- 如果行比较稀疏，或者由于页分裂导致数据存储不连续，聚蔟索引可能导致全表扫描速度变慢

**覆盖索引**
索引包含所有需要查询的字段的值


## 查询性能优化

#### Explain

用来分析SQL语句，分析结果中比较重要的字段有：

- select_type：查询类型，包含简单查询、联合查询和子查询 
-key：使用的索引
- rows：扫描的行数

#### 减少返回的列

慢查询主要原因是访问了过多的数据，除了访问过多的行之外，也包括访问过多的列。最好不要使用 SELECT * 语句，要根据需要选择查询的列。

#### 减少返回的行

最好使用LIMIT语句来取出想要的那些行。
建立索引来减少条件语句的全表扫描。不使用索引的情况可能需要进行全表扫描，而使用了索引只需要扫描几行记录即可，使用Explain语句可以通过观察rows字段来看出这种差异。

#### 拆分大的DELETE或INSERT语句

如果一次性执行的话，可能一次锁住很多数据、占满整个事物日志、耗尽系统资源、阻塞很多小的但重要的查询

## InnoDB   

InnoDB是MySQL的默认事务型引擎，只有在需要InnnoDB不支持的特性时，才考虑其他存储引擎。
采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读。
表是基于聚蔟索引建立的，它对主键的查询性能有很高的提升。
内部做了很多优化，包括从磁盘读取数据时采用的可预测性，能够自动在内存中建立hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。
通过一些机制和机制支持真正的热备份。

## MyISAM

MyISAM不支持事务和行级锁，而且奔溃后无法安全恢复。

只能对整张表加锁，而不是针对行。

MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。

如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表适合采用 MyISAM 压缩表。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机奔溃时会造成索引损坏，需要执行修复操作。

## 数据类型

#### 整型

TINYINT 8
SAMLLINT 16 
MEDIUMINT 24
INT 32
BIGINT 64
一般情况下越小的列越好，INT(11)中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

#### 浮点数

FLOAT和DOUBLE为浮点类型，DECIMAL为高精度小数类型。CPU原生支持浮点运算，但是不支持DECIMAL类型的计算，因此DECIMAL的计算比浮点类型需要更高的代价。
FLOAT、DOUBLE和DECIMAL都可以指定列宽，例如DECIMAL(18, 5)表示总共18位，取5位存储小数部分。

#### 字符串

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作，MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。

#### 时间和日期

MySQL 提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。

**DATATIME**



**TIMESTAMP**
