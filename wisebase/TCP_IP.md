# TCP/IP

## TCP三路握手

建立TCP的三路握手步骤如下：

- 服务器必须准备好接受外来的连接。这通常通过调用socket、bind和listen这3个函数来完成，称之为被动打开；
- 客户端通过调用connect发起主动连接。这导致客户TCP发送一个SYN分节，它通告服务器客户将在（待建立的）连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部及可能含有的TCP选项；
- 服务器必须确认（ACK）客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户端的ACK确认；
- 客户端必须确认服务器的SYN。

![](http://p5s0bbd0l.bkt.clouddn.com/tcp3.jpg)

在上图中，客户端的初始序列号为J，服务端的初始序列号为K。ACK的确认号是发送这个ACK端所期待的下一个序列号。因为SYN占据一个字节的序列号空间，所以每一个SYN的ACK确认号就是该SYN的初始序列号加1；类似地，每一个FIN的ACK确认号就是该FIN的序列号加1。

## TCP终止连接

TCP建立一个连接需要3个分节，终止一个连接则需要4个分节。

- 某个应用进程首先调用close，我们称为主动关闭。该端的TCP于是发送一个FIN分节，表示数据发送完毕；
- 接收到这个FIN的对端执行被动关闭。这个FIN由TCP确认，并传递给接收端应用进程（放在已排队等候该应用进程接收的任何数据之后），因为FIN的接收意味着接收端在连接上已经没有额外数据可以接收；
- 一段时间后，接收到这个FIN分节的应用进程将调用close关闭它的套接字，并发送一个FIN分节给对方；
- 接收这个最终FIN的原发送端TCP（即执行主动关闭的一端）确认这个FIN。

![](http://p5s0bbd0l.bkt.clouddn.com/tcp4.jpg)

这里说是“通常”需要4个分节是因为：某些情况下，步骤1的FIN分节可以随着数据一起被发送；另外，步骤2和步骤3即被动关闭端发送的FIN分节和ACK分节可以被合并成一个分节。

## TCP 状态

TCP为一个连接双方定义了11种状态，并且TCP规则规定如何基于当前状态及在当前状态下所接收的分节从一个状态转换到另一个状态。举例来说，当某个应用进程在CLOSED状态下执行主动打开时，其TCP将发送一个SYN，状态转为SYN_SENT。如果这个TCP接收到一个带ACK的SYN，它也会送回一个ACK，状态转为ESTABLISHED。这个最终状态是绝大多数连接数据传送发生的状态。

假设接收端和发送端都处于ESTABLISHED状态，某个应用进程在接收到一个FIN之前调用close（执行主动关闭），那就转换为FIN_WAIT_1状态；但如果某个应用进程在ESTABLISHED状态下，收到一个FIN分节（被动关闭），那就转为CLOSE_WAIT状态。

![](http://p5s0bbd0l.bkt.clouddn.com/tcp5.jpg)

在上图的例子中，客户端通告一个值为536的MSS（表明该客户端只实现了最小重组缓冲区大小），服务端通告一个值为1460的MSS（以太网上的IPv4的典型值）。不同方向上的MSS值不同不成问题。

一旦建立一个连接，客户就构造一个请求并发送给服务器。这里假设请求适合于单个TCP分节（即请求大小小于服务器通告的1460MSS）；服务器处理该请求的应答也适用于单个TCP分节（即应答大小小于客户端通告的536MSS）。如果服务器对客户端的请求确认是伴随着应答发送的，这种做法称为捎带，它通常发生于服务器处理请求并产生应答时间少于200ms时候发生；如果大于这个时间值，那么将先收到ACK再收到应答。

在上图中，如果整个连接的目的仅仅是发送单分节请求和接收单分节的应答，那么使用TCP会有8分节的开销。然而，如果使用UDP传输，那么只需要两个分节：一个请求分节和一个应答分节。使用UDP避免了TCP连接建立和终止所需的开销，但是这失去了TCP提供给应用进程的全部可靠性，迫使一大堆细节从TCP转移到使用UDP传输的应用进程，比如拥塞控制和快重传等。

## TIME_WAIT状态

TCP处于TIME_WAIT状态的时间是最长生命分节（MSS）的2倍，也被为2MSL。任何TCP都必须实现为MSL选择一个值，通常是30秒或者2分钟，所以TIME_WAIT的维持时间通常处于1分钟到4分钟之间。MSL是任何IP数据报能够在因特网上存活的最长时间，这个时间是有限的，因为每个数据报都一个跳限，每经过一个路由器跳值-1，直到为0丢弃数据报，我们假设最大跳限值（255）的分组在网络中的存活时间不可能超过MSL秒。

分组在网络中“迷途”通常是由于路由异常引起的。假设迷途的的分组是一个TCP分节，在它迷途之间，发送端TCP超时并重传该分组，然而迷途的分组和重传的分组都到达了目的地，TCP必须处理这些原来的“迷途的重复分组”。TCP的超时重传时间应该要小于等于MSL。

TIME_WAIT存在的两个理由：
1. 可靠地实现TCP全双工连接的终止；
2. 允许老的重复字节在网络中消逝；

#### 可靠地实现TCP全双工连接的终止

假设，上图中的LAST_ACK在网络中丢失。服务器由于没有收到ACK确认，会在一段时间后重新发送FIN分节，因此客户端必须维护TIME_WAIT状态，以此来接收LAST_ACK。想象一下，如果客户端没有TIME_WAIT状态，客户端在接收服务端重新发送的FIN分节，它将影响一个RST分节（重置连接），而这不是服务器所期望的ACK分节，会被服务器解释为错误。如果TCP打算彻底终止某个连接上两个方向的数据流（即全双工关闭），那么它必须正确处理连接终止4个分节中任何一个分节丢失的情况。

执行主动关闭的一端是处于TIME_WAIT状态的那一端：因为它可能不得不重传LAST_ACK。

#### 允许老的重复字节在网络中消逝

假设，在客户端127.0.0.1:12345和服务端101.132.181.76:80两个IP之间有一个TCP连接。这时我们关闭这个连接，过一段时间后在相同的IP地址和端口之间建立了另一个连接。TCP必须保证来自某个老的连接的老的重复分组在该连接断开后再次出现。为了做到这一点TCP将不给处于TIME_WAIT状态的连接发起新的连接。想象一下，LAST_ACK丢失，服务端在等待MSL时间之后，重新发送FIN分节，经过MSL时间之后到达客户端，一来一回，一共2个MSL的时间，所以TIME_WAIT维持的时间为2倍的MSL。而那些迷途的分节，将最多存活MSL时间之后被丢弃。


## TCP滑动窗口

TCP协议作为一个可靠的面向流的传输协议，其可靠性和流量控制由滑动窗口协议保证，而拥塞控制则由控制窗口结合一系列的控制算法实现。

#### 滑动窗口协议

所谓滑动窗口协议，可以理解为以下两点：
1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围被称之为“窗口”；
2. “滑动”指的是这段允许发送的范围是可以随着发送的过程而变化的，方式是按照顺序“滑动”。

- TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此发送者和接受者分别维护者一个独立的接受缓冲区和发送缓存区，由于对等性（A发B收和B发A收），这里以A发B收为例 ；
- 发送窗口是发送缓存区中的一部分，是可以被TCP协议发送的数据，可以这样理解，应用层需要发送的数据都被放进了发送缓存区；
- 发送窗口中有四个概念：
	- 已发送并收到确认的数据
	- 已发送但未收到确认的数据
	- 允许被发送但未发送的数据
	- 不允许被发送的数据
- 每次成功发送数据之后，发送窗口就会在发送缓存区中按顺序移动，将新的数据包含到窗口中准备发送。

TCP建立连接的初始，接收端B会告诉发送端A自己的接受窗口大小，比如20：
下图字节31-50为发送窗口

![](http://p5s0bbd0l.bkt.clouddn.com/window1.png)

发送端A发送了11个字节之后，发送窗口位置不变，接收端B收到了乱序的数据分组；

![](http://p5s0bbd0l.bkt.clouddn.com/window2.png)

只有当发送端A收到来自接收端B的确认ACK之后，才会移动滑动窗口离开已经发送窗口的数据；同时接收端B确认连续的数据分组，对于乱序的分组先接收下来，避免网络重复传输；

#### TCP利用滑动窗口机制实现流量控制

所谓流量控制，主要是接收方传递消息给发送方，使其发送数据不要太多（或者说太快），是一种端到端的控制。主要方式就是返回的ACK中包含自己接收窗口的大小，发送发根据此大小发送数据。

![](http://p5s0bbd0l.bkt.clouddn.com/window4.png)

这里涉及到一种情况：如果接收方告诉发送方自己的接收缓冲区已满，于是发送方就会停止发送数据。过了一段时间后，接收方的缓冲区还有400空余，于是告诉发送方自己的rwnd大小为400，但是这个报文不幸丢失了，这就会出现死锁：发送方等待接收方的通知 && 接收方等待发送方发送数据。

处理上述的情况，TCP引入持续计时器，当发送方接收到对端的rwnd=0的情况，就启用持续计时器，时间一到就发送一个探测报文，如果接收方还是返回rwnd=0，则重置持续计时器。

#### 考虑流量控制中的传输效率

一个显而易见的问题是：单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，无疑增加了网络的负担（试着想想为一个字节数据添加40字节的头部），所以TCP的原则是尽可能一次多发送几个字节，或窗口空余较多的时候再通知发送方一次发送多个字节。

使用Nagle算法处理尽可能一次多发送几个字节：
1. 若发送应用进程要把发送的数据逐个字节地由TCP传输，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来；
2. 当发送方接收到第一个字节的确认之后（此时也应该得到网络情况和对方接收窗口的大小），再把刚才缓存的剩余字节组成合适大小的报文发送出去；
3. 当到达的数据已达到发送窗口大小的一半，或者达到报文段的最大长度，就立即发送一个报文段。

让窗口空余较多的时候再通知发送方一次发送多个字节：让接收方等待一段时间，或者接收方获得足够空间容纳一个报文段，或者等到接收缓存有一半空闲的时候，再通知发送方发送数据。


## TCP拥塞控制

网络中的链路容量和交换交接中的缓存和处理机都有着工作极限，当网络的需求超过它们的工作极限时，就出现了拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不至于过载。常用方法：
1. 慢开始、拥塞控制
2. 快重传、快恢复

#### 慢开始和拥塞控制工作机制

- 发送方维持一个叫做“拥塞窗口”的变量，该变量和接收端的窗口共同决定了发送端的发送窗口；
- 当发送方开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个字节的试探报文；
- 当收到一个字节的数据确认后，就发送2个字节的报文，接着4字节，依次递增2的指数级；
- 最后会达到一个提前预设的“慢开始门限”，比如说16，即依次发送了16个分组，此时遵循下面的条件判断：
	- cwnd < ssthresh：继续使用慢开始算法，2的指数递增
	- cwnd > ssthresh：停止使用慢开始算法，改用拥塞避免算法
	- cwdn = ssthresh：既可以使用慢开始算法，也可以使用拥塞避免算法
- 拥塞避免算法：每经过一个往返时间RTT就把发送方的拥塞窗口+1，即让拥塞窗口慢慢按线性增长；
- 当出现网络拥塞，比如丢包时，将慢开始门限设为原来的一半，然后将cwnd设置为1，执行慢开始算法（较低的起点，指数级增长）。

![](http://p5s0bbd0l.bkt.clouddn.com/window5.png)

上述的方法的目的是在拥塞发生时候循序减少发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。慢开始和拥塞控制算法常常作为一个整体使用，而快重传和快恢复则是为了减少因为拥塞导致的数据丢包导致的重传时间，从而避免传递无用的数据到网络。

#### 快重传和快恢复工作机制

- 接收方建立这样的机制，如果一个包丢失，则发送三次重复ACK；
- 一旦发送方接收到三个一样的确认，就知道该包出现了错误，立刻重传该包；
- 此时发送方开始执行“快恢复”机制：
	- 慢开始门限减半；
	- cwnd为慢开始门限减半后的值；
	- 执行拥塞避免算法（高起点，线性增长）。
	
![](http://p5s0bbd0l.bkt.clouddn.com/window6.png)

#### 三次重复ACK

两次重复的ACK肯定是乱序造成的，而丢包肯定会造成三次重复ACK。

那为什么确定为三次，其实这只是一种权衡机制，大致原因是因为网络传输是不可靠的，丢包、乱序和复制等情况，如果出现三次以上的重复ACK就认为丢包的可能性很高，可以进入快速重传机制。

希望明确以下三点：
1. 接收到失序的数据包（可能由于丢失或乱序）时，需要马上触发重复的ACK，比如已经收到N-1序号的数据包，那么返回ACK=N，可是却继续接收到N+1，N+2 反正不是N，那么就会发送期望收到数据的序号包N；
2. 发送端收到三个重复的ACK，其实意思是总共四个相同的ACK，第一个为正常确认的ACK，后续三个为重复ACK；
3. 在实际抓包中，多数时候启动快速重传都会是在远大于3个重复ACK以后发生。


## 报文头

#### UDP报文头

头部长度：8字节

![](http://p5s0bbd0l.bkt.clouddn.com/header3.jpg)

- 16位源端口
- 16位目的端口
- 16位总长度，表示UDP包头长度和数据长度之和
- 16位校验和

#### TCP报文头

头部长度：一般为20字节，选项最多40字节，整个限制60字节。

![](http://p5s0bbd0l.bkt.clouddn.com/header1.png)

- 16位源端口号和16位目的端口号
- 32位序列号：一次TCP通信过程中某一个传输方向上的字节流的每个字节编号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000；
- 32位确认号：用来响应TCP报文段，给收到的TCP报文段的序号加1，三次握手时还要携带自己的序列号；
- 4位头部长度：标识该TCP头部有多个4字节，最长为15 × 4 = 60字节；
- 6位保留；
- 6位标识位：
	- URG 紧急指针是否有效
	- ACK 表确认号是否有效
	- PSH 提示接受端应用程序要立即从TCP缓冲区读走数据
	- RST 表示要求对方重新建立连接
	- SYN 表示请求建立一个连接
	- FIN 表示通知对方本端要关闭连接
- 16位窗口大小：TCP流量控制的一个手段，本端告知对端TCP缓冲区还能容纳多少字节；
- 16位校验和：由发送端填充，接收端对报文执行CRC算法检验TCP报文段在传输中是否损坏；
- 16位紧急指针：一个正的偏移量，他和序号段的值相加表示最后一个紧急数据的下一字节的序号。

#### IP报文头


![](http://p5s0bbd0l.bkt.clouddn.com/header2.jpg)

- 4位版本号：IPv4版本号位4；
- 4位首部长度：表示头部有多个4字节，即最大为15×4 = 60 字节；
- 8位服务类型：包含一个4位优先权字段：最小延时，最大吞吐量，最高可靠性和最小费用；
- 16位总长度：表示整个IP数据报的长度，最大表示65535，但由于MTU限制，一般无法到达这个值；
- 16位标识：唯一的标识数据报；
- 3位标识：保留、DF禁止分片和MF更多分片；
-13位分片偏移：分片相对于原始IP数据报开始处的偏移；
- 8位生存时间（TTL）：数据报到达目的地之前允许经过的路由跳跳数；
- 8位协议：用来区分上层协议（ICMP = 1，TCP = 6， UDP = 17）；
- 16位头部校验和：CRC算法检验数据头部在传输过程中是否损坏；
- 32位源IP和端口地址
- 32位目的IP和端口地址
- 可变长选项：
	- 记录路由，填充路过的路由IP;
	- 时间戳，记录每个路由转发的时间；
	- 松散路由选择：指定路由器IP地址列表，必须按这个表发送
	
**分片的作用：**

- 数据报标识：系统用+1法为每个数据报表唯一标识此位，如果数据报X被分片，所有的小分片中的此位都是X；
- 片偏移：表示当前数据报在完整数据报中的偏移，单位为8字节，比如偏偏移为100，那么代表该分片在完整数据报中的偏移是100 × 8 = 800 字节。