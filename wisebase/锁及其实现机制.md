# 锁的实现机制


## Lock接口

使用synchronized关键字会隐式获取锁，但是它将锁获取和释放固化了，也就是先获取再释放。而并发包中的Lock接口显示地获取和释放锁的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字不具备的同步特性。

```
	Lock lock = new ReentrantLock();
	lock.lock();
	try{
	
	}finally{
		lock.unlock();	//锁释放要放在finally语句中
	}
```

Lock接口提供synchronized不具备的特性：

- 尝试非阻塞地获取锁
- 能被中断地获取锁
- 超时获取锁

Lock接口的实现（比如ReentrantLock），基本通过聚合了一个同步器（AbstractQueueSynchronizer）的子类来完成线程的访问控制。

#### AQS

使用一个int变量表示同步状态，通过内置的FIFO队列来完成线程的排队工作。
同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程。

下面的代码展示的是一个独占锁的实现，独占锁就是在同一个时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于队列之中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁。

```java
// Mutex实现的是一个独占锁
public class Mutex implements Lock {
    private static class Sync extends AbstractQueuedSynchronizer{
        //一共有五个可以重写的方法
        //  protected boolean tryAcquire(int arg)   独占式获取同步状态
        //  protected boolean tryRelease(int arg)   独占式释放同步状态
        //  protected int     tryAcquireShared(int arg) 共享式获取同步状态 返回值大于0表成功
        //  protected boolean tryReleaseShared(int arg) 共享式释放同步状态
        //  protected isHeldExclusively()   判断是否在独占模式下被当前线程占用

        //AQS中提供3个方法来访问或者修改同步状态
        //  getState()  获取当前同步状态
        //  setState(int newState)  设置当前同步状态
        //  compareAndSetState(int expect, int update)  使用CAS设置当前状态, 该方法能保证设置状态的原子性

        //AQS提供的模板方法
        //  void acquire(int arg)
        //  void acquireInterruptibly(int arg)
        //  boolean tryAcquireNanos(int arg, long nanos)
        //  void acquireShared(int arg)
        //  void acquireSharedInterruptibly(int arg)
        //  boolean tryAcquireSharedNanos(int arg, long nanos)
        //  boolean release(int arg)
        //  boolean releaseShared(int arg)
        //  Collection<Thread> getQueueThreads()
        
        //是否处于占用状态
        protected boolean isHeldExclusively(){
            return getState() == 1;
        }
        //当状态为0的时候可以获取锁
        protected boolean tryAcquire(int acquires){
            if(compareAndSetState(0, 1)){
                //setExclusiveOwnerThread自JDK1.6被遗弃
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
        //释放锁, 将状态设置为0
        protected boolean tryRelease(int release){
            if(getState() == 0){ throw  new IllegalMonitorStateException(); }
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
        //返回一个Condition对象, 每个condition对象包含了一个condition队列
        Condition newCondition() { return new ConditionObject(); }
    }



    //以下六个函数为 实现Lock接口所需的
    //将操作代理到Sync上即可
    private Sync sync = new Sync();

    //获取锁, 调用该方法的当前线程会获取锁, 当获取锁之后, 从该方法返回
    public void lock() { sync.tryAcquire(1); }

    //可中断地获取锁
    //  和lock()方法不同之处在于该方法会响应中断,
    //  即在锁的获取中可以中断当前线程
    public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); }

    //尝试非阻塞地获取锁, 成功获取返回true
    public boolean tryLock() { return sync.tryAcquire(1); }

    //超时获取锁 有三种情况下会返回
    //  - 当前线程在时间内获取锁
    //  - 当前线程在时间内被中断
    //  - 超时结束 返回false
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    //释放锁
    public void unlock() { sync.release(1); }

    //条件变量 获取等待通知组件, 该组件和当前锁绑定
    //        当前线程只有获得了锁, 才能调用该组件的wait()方法
    //         而在调用之后, 当前线程将释放锁
    public Condition newCondition() { return sync.newCondition(); }


    //自定义开放接口
    public boolean isLocked() { return sync.isHeldExclusively(); }
    public boolean hasQueueThreads() { return sync.hasQueuedThreads(); }
}
```

