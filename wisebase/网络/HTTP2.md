# HTTP/2

#### 二进制帧

- 帧：HTTP/2数据通信的最小单位，指的是HTTP/2中逻辑上的HTTP消息，例如请求和响应等，消息由一个或多个帧组成
- 流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID

HTTP/2采用二进制格式传输数据，而非HTTP/1.X的文本格式，二进制协议解析起来更高效。HTTP/1.X的请求和响应报文使用换行符来切分数据，HTTP/2将请求和响应数据分割成更小的帧，并且它们采用二进制编码。

HTTP/2中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流表示可以重新组装。

#### 多路复用

多路复用，代替原来的序列和阻塞机制。就是所有的请求都是通过一个TCP连接并发完成。在HTTP/1.X中，如果想并发多个请求，必须使用多个TCP连接，且浏览器为了控制资源，还对单个域名有6-8个的TCP链接请求限制。

![](http://owj98yrme.bkt.clouddn.com/http2_1.jpg)

在HTTP/2中，有了二进制分帧之后，HTTP/2不再依赖TCP链接区实现多流并行，在HTTP/2中：

- 同域名下的所有通信都是在单个连接上完成的
- 单个连接可以承载任意数量的双向数据流
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为数据帧首部的流标识可以重新组装

提升的特性：

- 同个域名下只需占用一个TCP连接，消除了因多个TCP连接带来的延迟和内存消耗
- 单个连接上可以并行交错的请求和响应，之间互不干扰
- 在HTTP/2中，每个连接都可以带一个31bit的优先值，0表示最高优先级别，数值越大优先级越低。有了这个优先值，客户端和服务器可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。


#### 服务器推送

服务器可以在发送页面HTML时主动推送其他资源，而不用等到浏览器解析到相应的位置，发起请求再响应。例如服务器可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务器可以主动推送，客户端也有权利选择是否接收。如果服务器推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

#### 头部压缩

HTTP/1.1请求的大小变得越来越大，有时甚至会超过TCP窗口的初始大小，因为它们需要等待着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为HTTP/2头部设计的压缩）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.X每次请求，都会携带大量冗余头信息，浪费了很多宽带资源。

HTTP每一次通信都会携带一组头部，用于描述这次通信的资源、浏览器属性、Cookie等。

为了减少这块的资源的消耗并提升性能，HTTP/2对这些首部采取了压缩策略：

- HTTP/2在客户端和服务器使用“首部表”来跟踪和储存之前发送的Ket-Value，对于相同的数据，不再通过每次请求和响应发送
- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新
- 每个新的首部Key-Value要么被追加到当前表的末尾，要么更新表中的值。

例如：下面的两个请求，请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。

![](http://owj98yrme.bkt.clouddn.com/http2_2.jpg)


#### keep-alive

HTTP/1.1开启keep-alive只是减少了TCP三次握手和SSL的三次或四次握手时间，然而在并发性，HTTP/1.1与HTTP/2是无法比较的，即使HTTP/1.1使用Pipeline或者Nginx端也是串行处理的。


#### HTTP/1.1和HTTP/2的动图比较

https://http2.akamai.com/demo


