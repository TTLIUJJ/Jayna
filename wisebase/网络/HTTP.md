# HTTP

## HTTP工作流程

从网络分层模型来看，HTTP工作在应用层，在传输层TCP协议之上为其服务。在HTTP协议服务之前，客户端与服务端一定通过三次握手建立起连接。

一次完整的HTTP请求事务包含以下四个环节：

- 建立客户端与服务端的连接。
- 连接建立之后，客户端发送一个请求给服务端。
- 服务端接受到请求之后返回响应信息。
- 客户端浏览器将返回的信息解析并呈现，之后断开连接。

## HTTP主要特点

- 简单快速：客户端向服务端请求服务时，只需传送请求方法、请求资源和协议版本号，以及一些可选的请求头属性和请求参数。由于协议简单，使得HTTP服务器程序规模较小，因为通信速度很快。
- 灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。
- 无连接：HTTP/1.0的实现方式是无连接的，其含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态：客户端向服务端发送请求，继而HTTP服务器将相应的资源返回给客户端这样一个过程，无论对于客户端还是服务器，都没有必要记录这个过程，因为每一次请求和响应都是相对独立的。就是HTTP协议对事务处理没有记忆能力。缺少状态意味着后续处理如果需要前面的信息，那么前面的信息需要重传，导致请求的数据量加大；相反地，无信息的记忆，有利于提高应答速度。


#### KeepAlive

HTTP/1.1协议中，Connection在请求头中的默认实现是keep-alive，使得客户端和服务端的连接持续有效，当出现了客户端对服务器的后继请求，keep-alive功能避免了重新建立连接。

在网页越来越复杂的年代，比如一个页面中嵌入了大量的图片、JS文件和CSS文件，并且这些资源都存在同一个HTTP服务器，这时每次访问这些文件可能都需要建立一次TCP连接就显得十分低效。相反地，如果只是一个用户端即使生成的动态网页，并且不引用其他内容，那么keep-avlive就不适合了。

开启keep-alive同样会影响服务器的性能，因为在处理暂停期间，本来可以释放的资源仍然被占用。

#### Cookie和Session

在客户端和服务器需要实现动态交互的Web应用程序出现后，HTTP的无状态特性严重阻碍交互功能的实现，比如简单的购物车功能也要知道用户在之前选择了什么商品。Cookie和Session的出现就是用来解决HTTP的无状态出现的问题。

Cookie是保存在客户端的一组值，每个Cookie可能对应着某个网站可以识别身份的值。比如客户端在于服务器建立连接的时候，发送Cookie值，服务器通过识别Cookie来判断浏览器用户是否在以前点击了免登陆操作；又比如购物车功能，每次访问淘宝网都会记录我的购物车添加物品，保存了用户的状态。

---

与Cookie相对的一个解决方案是Session，它是通过服务器来保持状态的。

客户端初次请求时，如果会使用到Session，此时服务端通过响应头中的Set-Cookie这样一个header项，把SeesionId写回浏览器的Cookie中，这种Cookie也被称为SessionCookie，在整个浏览器关闭之后，就被清除了。

在一次浏览器会话期间，当客户端再次请求，浏览器的请求头会包含Cookie这样一项header，即刚刚服务器返回给浏览器的SessionId，服务器根据此SeesionId配置之前为请求创建的Sesssion，从而所有以这个Session保存的的信息都被返回给浏览器。

服务端的SessionId默认超时时间是30分钟，如果一直保持请求活动状态，会不断更新SessionId的过期时间。SesssionId在服务端可以存在硬盘或者内存中。

由于SessionId在客户端是保存在浏览器中，一旦关闭了浏览器进程，该以Cookie实现的SessionId就丢失了，再次打开浏览器访问服务器，生成的是不同的SessionId，而先前的SessionId会在过期之后被删除。

## HTTP协议结构

#### 请求报文

HTTP请求报文主要包含如下四个部分，每一行的数据必须通过"\r\n"分割，这里可理解为行末标识符。

- 请求行（只有一行）
结构：method uri version
	- method
	HTTP请求方法，一共有9种，但基本只使用GET和POST两种方法。
	- uri
	用来指代请求的文件。
	- version
	HTTP协议版本，该字段包括HTTP/1.0和HTTP/1.1两种。
- 请求头（可以不止一行）
在HTTP/1.1中，请求头除了Host都是可选的，HTTP请求包含多种，下面介绍几种
	- Host：指定请求资源的主机和端口号。默认端口号80
	- Connection：值为keep-alive和close。keep-alive使服务端持续与客户端的有效连接，可以进行多次请求，在一次连接之后。此功能为HTTP/1.1预设功能。
	- Accept：浏览可以接受的MIME类型。比如text/html,image/gif，如果服务器无法返回浏览器可识别的类型，返回406错误。
	- Cache-control：缓存控制，Public内容可以被任何缓存保存，Private内容只能被缓存到私有缓存；non-cache指所有内容都"不会"被浏览器缓存。
	- Content-length：请求消息正文长度。
	- Cookie：将存储在本地的Cookie值发送给服务器，服务端可以识别客户端。

- 空行（只有一行）

- 请求正文（可以不止一行）
POST方法才可能有请求正文，GET没有

--- 

#### 响应报文

响应报文是服务器对请求资源的响应，同样地，数据也是以"\r\n"来进行分割

- 状态行（只有一行）
结构：version statusCode statusMessage
	- version
	描述所遵循的HTTP协议版本号
	- statusCode
	返回状态码，表示对请求的处理结果，常见状态码如下：	
		- 200 请求成功
		- 301 永久重定向
		- 302 临时重定向
		- 304 表示该请求资源被浏览器缓存了，不需要重新请求服务器
		- 400 请求语义有无法被服务器理解，或者请求参数有误
		- 401 请求访问权限不足
		- 403 服务器理解请求，但是拒绝执行它，比如IP被禁止
		- 404 请求失败，请求希望得到的资源未在服务器发现
		- 500 服务器内部错误，无法完成请求处理
		- 501 服务器不支持所请求的方法
		- 505 服务器不支持所请求的版本
		
	- statusMessage
	显示和statusCode等价的描述
	
- 响应头（可以不止一行）
	- Date：表示服务端信息发送的时间
	- Server：HTTP服务器用来处理请求的名字
	- Content-Encoding：服务器告知浏览器响应正文的压缩格式(如GZIP)
	- Content-Length：服务器告知浏览器响应正文的长度
	- Content-Type：服务器告知浏览器消息正文的类型
	
- 空行（只有一行）

- 消息正文（可以不止一行）

## HTTP请求方法

HTTP/1.0定义的三种请求方法：GET、POST和HEAD方法
HTTP/1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE和CONNECT方法。

- GET
请求指定的页面信息，并返回请求实体
- HEAD
类似与GET请求，只不过返回的响应中没有具体的内容，用于获取响应头
- POST
向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求正文中。POST可能会导致新的资源建立或者已有资源的修改。
- PUT
从客户端想服务器传送的数据，取代指定的文档的内容。
- DELETE 请求服务器删除指定的页面。
- CONNECT HTTP/1.1协议中预留能够将连接改为管道方式的的代理服务器。
- OPTIONS 允许客户端查看服务器的性能。
- TRACE 回显服务器收到的请求，主要用于测试或者诊断。

#### GET和POST方法

对于这两个常用方法，关注以下几个点：

**长度限制问题**

GET：
1. GET是通过URL提交数据，因此GET可以提交的数据量就跟URL所能达到的最大长度有直接关系。
2. 实际上HTTP协议对URL长度是没有限制的。
3. 限制URL长度多数是浏览器或者服务器的配置参数。

POST：
1. POST请求通过请求正文提交数据。
2. 同样的，HTTP协议也没有对POST的长度做任务限制，一般是限制于服务器参数配置或者内存大小。

**请求头的Content-Length问题**

如果有人恶意伪造Content-Length为很大的数值，但实际上发送很小的请求，这样服务器会一直干等，直到超时。当然服务器可以通过设置来避免该问题。

**安全性问题**

GET是通过URL方式请求，可以直接看到，属于明文传输。
POST将请求数据放在请求正文，但是也是可以通过开发者工具或者抓包看到，其实也是数据明文的，但安全性远高于GET。
GET请求会保存在浏览器的历史记录中。

**作用于服务器状态的问题**

根据HTTP协议的设计，在请求GET的时候，都期望这个请求对服务器没有修改；而请求POST的时候，都认为其对服务器进行了修改。

**幂等问题**

幂等是指同一个请求方法执行多次和仅执行一次的效果是相同的。
1. 根据RFC规范，PUT、DELETE和安全方法都是幂等的。虽说是规范，但服务器实现是否幂等是无法确保的。
2. 引入幂等主要是为了处理同一个请求重复发送的情况。比如在请求返回响应之前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复发送请求可能会带来意想不到的后果。
3. 举个例子，在微博场景里的运用：GET语义用在“查看我在某个TimeLine上最新的20条微博”；POST语义用在“发微博、评论和点赞”这样的场景中。

## URL和URI

以下面这个网址解释两者的区别：

http://news.xmu.edu.cn/18/af/c1552a333999/page.htm

#### URI

URI包括：/18/af/c1552a333999/page.htm

#### URL

URL为链接全部，包含了三个部分

- 指定协议类型（HTTPS）
- 在哪里获取（http://news.xmu.edu.cn）
- 获取什么资源（/18/af/c1552a333999/page.htm）

其实URI和URL都定义了 what the resource is，而URL还定义了 how to get the resource。

## 分块传送

对于非持续连接，浏览器可以通过是否关闭或者响应正文的边界（"\r\n"）来识别数据是否传输完毕，而对于持续连接，这种方法显然不奏效。比如，服务端已经发送完全部数据，但是浏览器并不知道，它无法知道这个连接是否还会有数据到达，只能傻傻等待。

当浏览器向服务器请求一个资源时，这个资源是一个动态资源，服务器无法提前预知资源的大小， 使用Content-Type无法顺利解决，这个时候就可以使用分块传输，不依赖长度的信息，也能知道消息正文的边界。

服务器先生成一个chunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到资源全部传送完成。

分块传输需要在请求头增加一个特殊的键值Transfer-Encoding: Chunk，那么消息体的内容便是分块传送。

![](http://p5s0bbd0l.bkt.clouddn.com/chunk1.jpg)

## Pipeline管线化

HTTP/1.0不支持管线化，同一个连接处理请求的顺序是逐个应答模式，出一个请求就需要耗费一个TTL，也就是客户端到服务端的时间，处理N个请求就是N个TTL时长，当页面的请求非常多，页面的加载速度就会非常缓慢

![](http://p5s0bbd0l.bkt.clouddn.com/pipeline1.jpg)

从HTTP/1.1开始要求服务器支持管线化，可以同时将多个请求发送到服务器，然后逐个读取响应。响应顺序必须和请求顺序保持一致。

![](http://p5s0bbd0l.bkt.clouddn.com/pipeline2.jpg)
