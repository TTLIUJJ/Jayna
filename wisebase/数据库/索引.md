# 索引

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。


## B-树索引

![](http://p5s0bbd0l.bkt.clouddn.com/sql3.jpg) 

为了描述B-Tree，首先定义一条数据记录为一个二元组[Key, data]，key为记录的键，data为数据记录除key外的数据。

**特性：**
1. 所有叶子节点都具有相同的深度，也就是说B-Tree是平衡的
2. 一个节点中的key从左到右非递减排列 

在B-Tree中按key检索数据的算法非常直观，首先从根节点进行二分查找，如果找到则返回对应节点的data，否则回溯递归搜索进行查找。

由于插入删除新的数据记录会破坏B-Tree性质，因此在插入删除时，需要对树进行分裂、合并的、转移等操作以保持B-Tree性质。

## B+树索引

B+树非叶节点存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。
所有的叶节点在同一层，包含了全部关键码和相应的数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。

![](http://p5s0bbd0l.bkt.clouddn.com/sql4.png) 

**特性：**
1. 所有关键字都出现在叶子节点的链表中，且链表中的关键字是有序的。
2. 不可能在非叶子节点命中。
3. 非叶子节点相当于是叶子节点的索引
4. 更适合做文件索引系统

在B+树的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是提高区间的访问速度。

两种搜索方式：一种是从根节点到叶节点搜索，另一种是按叶节点自己拉起的链表顺序搜索。

## 背景知识

红黑树等数据结构也可以用来实现索引，但是文件系统及数据库普遍采用B-/+ Tree作为索引结构。

页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续大小相等的块，每个存储块称为页（大小通常为4K），主存和磁盘以页为单位交换数据。

局部性原理，磁盘不是按需读取数据，每次都会进行预读。

- 当一个数据被用到时，其附近的数据也通常会马上被使用
- 程序运行期间所需要的数据通常比较集中
- 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

## 为什么使用B+ Tree

- 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘中。
- 索引，即快速定位和查找，那么索引的组织结构要尽量减少查找过程中的磁盘I/O的存取次数（B+树相对于B树，B+树的内部节点没有指向关键字具体信息的指针，其内部结构比B树小，一次页读取能够查找的关键字也就更多，I/O读写次数也就更少）。
- 局部性原理与磁盘预读，预读为页的整数倍。数据库系统利用磁盘预读技术，将一个节点的大小设为一页，每个节点只需一次I/O就可以完全载入，而红黑树的树深度明显会很深，逻辑上很近的节点（父子节点）在物理上才磁盘上可能会很远，无法利用局部性
- B+树直接从叶节点快速扫库，而B树需要按中序遍历，B+树支持随机访问
- B+树查找复杂度O(logdN)，d为节点的出度


## B-/+ Tree索引性质

适用于全键值、键值范围或者最左前缀的查找。适用于如下类型的查询：

```sql
	CREATE TABLE `People`(
		`last_name` varchar(50) not null,
		`first_name` varchar(50) not null,
		`dob` date not null,
		`age` int not null,
		`gender` enum('m', 'f') not null,
		primary key(`last_name`, `first_name`, `dob`)	
	);
```

**全值匹配：** 查询和索引中的所有列进行匹配，例如查找名字为 Cuba Allen，出生于1960-01-01的人

**匹配最左前缀：** 查询last_name为Allen的人，即匹配索引的第一列

**匹配列前缀：** 匹配某一列的值的开头部分，使用索引的第一列，查询last_name以A为开头的人，然而却不能使用以Z为结尾的人

**精确匹配某一列并范围匹配另一列：** 例如，查询last_name为全匹配，而first_name为范围匹配

**只访问索引的查询：** “覆盖索引”，即查询只需要访问索引，而无须访问数据行。

**其他功能：**还可以用于排序Order By和分组 Group By。

## 无效的索引查询

以下SQL语句无法使用索引直接查询

**如果不是按照索引的最左列开始查找，则无法使用索引：**

```
	mysql> select * from table where first_name = 'aaa';
	mysql> select * from table where dob = '1999-9-9';
```

**不能跳过索引中的列：**

```
	mysql> select * from table where last_name = 'aaa' and age=26;
```

**如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找：**

```
	mysql> select * from table 
			where last_name = 'aaa' AND first_name LIKE '%b' AND age = 26;
```

这个查询只能使用索引的前两列，索引age并没有被用上

## 高性能的索引策略

索引优点：

- 大大减少服务器需要扫描的数量
- 帮助服务器避免进行排序和创建临时表
- 将随机I/O变为顺序I/O

#### 独立的列

在进行查询的时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用actor_id列的索引：

```
	SELECT actor_id FROM table WHERE actor_id + 1 = 5;
```

#### 前缀索引

对于索引很长的字符列，这会让索引变得大并且慢。使用前缀索引，只索引开始的部分字符。
对于前缀长度的选取需要根据 索引选择性 来确定：不重复的索引值和记录总长度的比值。选择性越高，查询效率越高。最大值为1，此时每个记录都有唯一的索引与之相对应。

```
	mysql> SELECT count(*) AS cnt, LEFT(last_name, 3) AS pref
			FROM table GROUP BY pref;
```

#### 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句，最好把索引设置为多列索引。

```
	mysql> CREATE TABLE t(
			last_name varchar(10),
			age int,
			index(last_name),
			index(age)
			);
	mysql> SELECT * FROM t
			WHERE last_name='aaa' OR age = 1; 
```

#### 索引列的顺序

让选择性强的索引列放在前面，比如name的选择性比sexy更高，因此最好把name列放在多列索引的前面


#### 覆盖索引

索引包含所有需要查询的字段的值，通俗的讲，就是在查询的时候，只用去读取索引而得到的数据，无需在二次Select相关的表。

```sql
//比如下句sql语句，我们只建立了b的索引
//那么查询的时候，首先检索b找到其对应的索引
//				然后根据索引去检索正确的数据行
//这样就需要检索两次
mysql >SELECT a FROM table WHERE b = 5;

//使用覆盖索引，只需一次检索
mysql >ALTER table ADD INDEX(b, a);
```

## 聚蔟索引

聚蔟索引并不是一种索引类型，而是一种数据存储方式。
术语“聚蔟”表示数据行和相邻的键值紧密地存储在一起，InnoDB的聚蔟索引的数据行放在B+Tree的叶子页中。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚蔟索引。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB使用一个非空索引来替代。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚蔟索引。

![](http://p5s0bbd0l.bkt.clouddn.com/sql5.jpg) 

优点：

- 可以把相关的数据放在一起，减少I/O操作；
- 因为数据保存在B+Tree中，因此数据访问更快。

缺点：

- 聚蔟索引最大限度地提高了I/O密集型应用的性能，但是如果数据全部放在内存，就没有必要用聚蔟索引
- 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的
- 更新操作代价很高，因为每个更新的行都会被移动到新位置
- 插入到某个已满的页，会导致页分裂，使得表占用更多的磁盘空间
- 如果行比较稀疏，或者由于页分裂导致数据存储不连续，聚蔟索引可能导致全表扫描速度变慢

---

## 哈希索引

基于哈希表的实现，优点是查找非常快。

在MySQL中只有Memory引擎中显式支持哈希索引。

InnoDB引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常
频繁，会在B-Tree索引上再创建一个哈希索引，这样可以让B-Tree索引具有哈希索引的一些优点，比如快速的哈希查找。

**限制**：哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
只支持精确查找，由于索引数据不是按索引值排序，所以无法用于排序；
只支持等值比较查询，无法用于范围查询；
无法用于部分索引列匹配查找；
哈希索引冲突，使用链表方式解决

## 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。

使用 MATCH AGAINST，而不是普通的 WHERE。
