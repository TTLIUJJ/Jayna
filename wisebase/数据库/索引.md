# 索引

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。



## B-树索引

![](https://github.com/CyC2018/InterviewNotes/raw/master/pics//5ed71283-a070-4b21-85ae-f2cbfd6ba6e1.jpg) 

为了描述B-Tree，首先定义一条数据记录为一个二元组[Key, data]，key为记录的键，data为数据记录除key外的数据。

**特性：**
1. 所有叶子节点都具有相同的深度，也就是说B-Tree是平衡的
2. 一个节点中的key从左到右非递减排列 

在B-Tree中按key检索数据的算法非常直观，首先从根节点进行二分查找，如果找到则返回对应节点的data，否则回溯递归搜索进行查找。

由于插入删除新的数据记录会破坏B-Tree性质，因此在插入删除时，需要对树进行分裂、合并的、转移等操作以保持B-Tree性质。

## B+树索引

B+树非叶节点存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。
所有的叶节点在同一层，包含了全部关键码和相应的数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。

![](https://images2015.cnblogs.com/blog/1048139/201704/1048139-20170408134632082-1550342422.png) 

**特性：**
1. 所有关键字都出现在叶子节点的链表中，且链表中的关键字是有序的。
2. 不可能在非叶子节点命中。
3. 非叶子节点相当于是叶子节点的索引
4. 更适合做文件索引系统

在B+树的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是提高区间的访问速度。

两种搜索方式：一种是从根节点到叶节点搜索，另一种是按叶节点自己拉起的链表顺序搜索。

## 为什么使用B-/+ Tree

红黑树等数据结构也可以用来实现索引，但是文件系统及数据库普遍采用B-/+ Tree作为索引结构。

页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续大小相等的块，每个存储块称为页（大小通常为4K），主存和磁盘以页为单位交换数据。

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘中。为了减少磁盘的I/O，磁盘往往不是严格按需读取，而是每次都会预读。这样是因为局部性原理：当一个数据被用到时，其附近的数据也通常马上会被使用。将一个节点的大小设为一页，这样每个节点只需要一次I/O就可以完全载入。B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），查找复杂度为O(h) = O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。而红黑树这种数据结构，树的明显要深得多。并且由于逻辑上很近的节点（父子）物理上可能会很远，无法利用局部性，效率明显比B-Tree差很多。

B+Tree更适合外存索引，原因和内节点的出度d有关，由于B+Tree内节点丢掉了data域，因此拥有更大的出度，拥有更好的性能，查找时间更均匀。

## B-/+ Tree索引性质

适用于全键值、键值范围或者最左前缀的查找。适用于如下类型的查询：

```
	CREATE TABLE People(
		last_name varchar(50) not null,
		first_name varchar(50) not null,
		dob date not null,
		age int not null,
		gender enum('m', 'f') not null,
		key(last_name, first_name, dob)	
	);
```

**全值匹配：** 查询和索引中的所有列进行匹配，例如查找名字为 Cuba Allen，出生于1960-01-01的人

**匹配最左前缀：** 查询last_name为Allen的人，即匹配索引的第一列

**匹配列前缀：** 匹配某一列的值的开头部分，使用索引的第一列，查询last_name以A为开头的人，然而却不能使用以Z为结尾的人

**精确匹配某一列并范围匹配另一列：** 例如，查询last_name为全匹配，而first_name为范围匹配

**只访问索引的查询** ：“覆盖索引”，即查询只需要访问索引，而无须访问数据行。

除了用于查找，还可以用于排序Order By和分组 Group By。

#### 限制

以下SQL语句无法使用索引直接查询

**如果不是按照索引的最左列开始查找，则无法使用索引：**

```
	mysql> select * from table where first_name = 'aaa';
	mysql> select * from table where dob = '1999-9-9';
```

**不能跳过索引中的列：**

```
	mysql> select * from table where last_name = 'aaa' and age=26;
```

**如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找：**

```
	mysql> select * from table 
			where last_name = 'aaa' AND first_name LIKE '%b' AND age = 26;
```

这个查询只能使用索引的前两列，索引age并没有被用上

## 哈希索引

基于哈希表的实现，优点是查找非常快。

在MySQL中只有Memory引擎中显式支持哈希索引。

InnoDB引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常
频繁，会在B-Tree索引上再创建一个哈希索引，这样可以让B-Tree索引具有哈希索引的一些优点，比如快速的哈希查找。

**限制**：哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
只支持精确查找，由于索引数据不是按索引值排序，所以无法用于排序；
只支持等值比较查询，无法用于范围查询；
无法用于部分索引列匹配查找；
哈希索引冲突，使用链表方式解决

## 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。

使用 MATCH AGAINST，而不是普通的 WHERE。

## 高性能的索引策略

**索引优点：**

- 大大减少服务器需要扫描的数量
- 帮助服务器避免进行排序和创建临时表
- 将随机I/O变为顺序I/O

**独立的列**

在进行查询的时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用actor_id列的索引：

```
	SELECT actor_id FROM table WHERE actor_id + 1 = 5;
```

**前缀索引**

对于索引很长的字符列，这会让索引变得大并且慢。使用前缀索引，只索引开始的部分字符。
对于前缀长度的选取需要根据 索引选择性 来确定：不重复的索引值和记录总长度的比值。选择性越高，查询效率越高。最大值为1，此时每个记录都有唯一的索引与之相对应。

```
	mysql> SELECT count(*) AS cnt, LEFT(last_name, 3) AS pref
			FROM table GROUP BY pref;
```

**多列索引**

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句，最好把索引设置为多列索引。

```
	mysql> CREATE TABLE t(
			last_name varchar(10),
			age int,
			index(last_name),
			index(age)
			);
	mysql> SELECT * FROM t
			WHERE last_name='aaa' OR age = 1; 
```

**索引列的顺序**

让选择性强的索引列放在前面，比如name的选择性比sexy更高，因此最好把name列放在多列索引的前面

**聚蔟索引**

聚蔟索引并不是一种索引类型，而是一种数据存储方式。
术语“聚蔟”表示数据行和相邻的键值紧密地存储在一起，InnoDB的聚蔟索引的数据行放在B-Tree的叶子页中。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚蔟索引。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB使用一个非空索引来替代。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚蔟索引。

![](https://github.com/CyC2018/InterviewNotes/raw/master/pics//b9e9ae8c-e216-4c01-b267-a50dbeb98fa4.jpg) 


优点：

- 可以把相关的数据放在一起，减少I/O操作；
- 因为数据保存在B-Tree中，因此数据访问更快。

缺点：

- 聚蔟索引最大限度地提高了I/O密集型应用的性能，但是如果数据全部放在内存，就没有必要用聚蔟索引
- 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的
- 更新操作代价很高，因为每个更新的行都会被移动到新位置
- 插入到某个已满的页，会导致页分裂，使得表占用更多的磁盘空间
- 如果行比较稀疏，或者由于页分裂导致数据存储不连续，聚蔟索引可能导致全表扫描速度变慢

**覆盖索引**

索引包含所有需要查询的字段的值

