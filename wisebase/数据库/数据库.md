# 数据库

## 事务

事务由一个或多个sql语句组成一个整体，如果所有的语句执行成功那么修改将会全部生效，如有一条语句失败，那么该事务被成功执行的sql语句会被撤销，只有在该事务中所有的语句全部执行成功的情况下，修改的数据才会被提交到数据库。

**事务的特性**：ACID

- 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

- 一致性（Consistency）：一个事务执行之前和执行之后都必须处于一致性状态。比如，假设账户A和账户B两者一共有100块，不管A和B之间如何转账，转账几次，事务结束之后两个用户的钱相加起来应该还的是100。能量守恒定律。

- 隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，某个事务不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

- 持久性（Durability）：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。MySQL中会保存有相应的操作日志，即使遭遇故障依然能够通过日志回复最后一次更新。

**隔离级别**

用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离别一般是支持更高的并发处理，并拥有更低的系统开销。

- Read Uncommitted（读取未提交读）
读取未提交的数据，也被称为脏读。所有的事务都可以看到其它未提交事务的执行的结果。很少用于实际应用。事务A查询X的值未返回之前，事务B修改了X，事务A获得了非最新的实际值。

- Read Committed（读取提交内容）
满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。这种隔离级别也支持所谓的不可重复读，因为同一个事务的其他实例在该实例处理期间可能会有新的Commit，所以同一个select可能返回不同的结果。比如，事务A的两次查询X之间，事务B更新了X的值，那么事务A的两次查询结果将会不同。

- Repeatable Read（可重读）
MySQL默认事务隔离级别，它确保同一个事务的多个实例在并发读取数据的时候，会看到同样数据行。产生了一个棘手的问题：幻读。幻读是指当事务不是独立执行时发生的一种现象。比如，事务A修改了全表的数据行，同时事务B向表插入新一行数据。那么以后处理事务A的用户发现表中还有未修改的数据行。
通过存储引擎的多版本并发控制间隙锁机制解决了该问题。多版本并发控制只是解决了不可重复读的问题，而加上间隙锁（控制并发控制）才解决了幻读。

- Seriablizable（可串行化）
在每个读的数据行上加上共享锁，在这个最高级别的隔离级别上，可能导致大量的超时现象和锁竞争。

MVVC是为了减少加锁而引入，从而来提高并发性。MVVC只工作在repeatable readl和read commit两个隔离级别。而read uncommited每次只管读取最新版本的数据行，seriableable则会对每个读操作加锁，所以不需要MVCC。


## InnoDB   

InnoDB是MySQL的默认事务型引擎，只有在需要InnnoDB不支持的特性时，才考虑其他存储引擎。
采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读。
表是基于聚蔟索引建立的，它对主键的查询性能有很高的提升。
内部做了很多优化，包括从磁盘读取数据时采用的可预测性，能够自动在内存中建立hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。
通过一些机制和机制支持真正的热备份。

## MyISAM

MyISAM不支持事务和行级锁，而且奔溃后无法安全恢复。

只能对整张表加锁，而不是针对行。

MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。

如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表适合采用 MyISAM 压缩表。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机奔溃时会造成索引损坏，需要执行修复操作。


## 查询性能优化

#### Explain

用来分析SQL语句，分析结果中比较重要的字段有：

- select_type：查询类型，包含简单查询、联合查询和子查询 
-key：使用的索引
- rows：扫描的行数

#### 减少返回的列

慢查询主要原因是访问了过多的数据，除了访问过多的行之外，也包括访问过多的列。最好不要使用 SELECT * 语句，要根据需要选择查询的列。

#### 减少返回的行

最好使用LIMIT语句来取出想要的那些行。
建立索引来减少条件语句的全表扫描。不使用索引的情况可能需要进行全表扫描，而使用了索引只需要扫描几行记录即可，使用Explain语句可以通过观察rows字段来看出这种差异。

#### 拆分大的DELETE或INSERT语句

如果一次性执行的话，可能一次锁住很多数据、占满整个事物日志、耗尽系统资源、阻塞很多小的但重要的查询


## 键和索引


主键不能重复，不能为空
唯一键不能重复，可以为空

- 普通索引

```sql
	mysql >ALTER TABLE `table_name` ADD INDEX index_name(`column`);
```

- 唯一索引，不允许索引的列拥有重复的值

```
	mysql >ALTER TABLE `table_name` ADD UNIQUE(`column`);
```

- 主索引，创建主键会自动创建主键索引

```
	mysql >ALTER TABLE `table_name`ADD PRIMARY KEY(`column`); 
```

- 复合索引，需要符合最左前缀匹配

```
	mysql >ALTER TABLE `table_name` ADD INDEX index_name(`colnum1`, `colnum2`, `colnum3`);	
```

## JOIN



## 数据类型

#### 整型

```
TINYINT 8
SAMLLINT 16 
MEDIUMINT 24
INT 32
BIGINT 64
```

一般情况下越小的列越好，INT(11)中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

#### 浮点数

FLOAT和DOUBLE为浮点类型，DECIMAL为高精度小数类型。CPU原生支持浮点运算，但是不支持DECIMAL类型的计算，因此DECIMAL的计算比浮点类型需要更高的代价。
FLOAT、DOUBLE和DECIMAL都可以指定列宽，例如DECIMAL(18, 5)表示总共18位，取5位存储小数部分。

#### 字符串

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作，MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。

#### 时间和日期

MySQL 提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。

**DATATIME**



**TIMESTAMP**
