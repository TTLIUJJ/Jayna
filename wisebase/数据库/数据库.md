# 数据库

## 事务

事务由一个或多个sql语句组成一个整体，如果所有的语句执行成功那么修改将会全部生效，如有一条语句失败，那么该事务被成功执行的sql语句会被撤销，只有在该事务中所有的语句全部执行成功的情况下，修改的数据才会被提交到数据库。

#### 事务的特性：ACID

- 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

- 一致性（Consistency）：一个事务执行之前和执行之后都必须处于一致性状态。比如，假设账户A和账户B两者一共有100块，不管A和B之间如何转账，转账几次，事务结束之后两个用户的钱相加起来应该还的是100。能量守恒定律。

- 隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，某个事务不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

- 持久性（Durability）：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。MySQL中会保存有相应的操作日志，即使遭遇故障依然能够通过日志回复最后一次更新。

#### 隔离级别

用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离别一般是支持更高的并发处理，并拥有更低的系统开销。

- Read Uncommitted（脏读）
读取未提交的数据，也被称为脏读。所有的事务都可以看到其它未提交事务的执行的结果。很少用于实际应用。事务A查询X的值未返回之前，事务B修改了X，事务A获得了非最新的实际值。

![](http://p5s0bbd0l.bkt.clouddn.com/sql7.png) 

- Read Committed（不可重复读）
读取提交内容，满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。这种隔离级别也支持所谓的不可重复读，因为同一个事务的其他实例在该实例处理期间可能会有新的Commit，所以同一个select可能返回不同的结果。比如，事务A的两次查询X之间，事务B更新了X的值，那么事务A的两次查询结果将会不同。

![](http://p5s0bbd0l.bkt.clouddn.com/sql6.png) 

- Repeatable Read（幻读）
MySQL默认事务隔离级别，它确保同一个事务的多个实例在并发读取数据的时候，会看到同样数据行。产生了一个棘手的问题：幻读。幻读是指当事务不是独立执行时发生的一种现象。比如，事务A修改了全表的数据行，同时事务B向表插入新一行数据。那么以后处理事务A的用户发现表中还有未修改的数据行。
通过存储引擎的多版本并发控制间隙锁机制解决了该问题。多版本并发控制只是解决了不可重复读的问题，而加上间隙锁（控制并发控制）才解决了幻读。

![](http://p5s0bbd0l.bkt.clouddn.com/sql8.png) 

- Seriablizable（串行）
在每个读的数据行上加上共享锁，在这个最高级别的隔离级别上，可能导致大量的超时现象和锁竞争。

## InnoDB事务隔离级别和锁

- 一次封锁：在事务开始阶段，将运行需要用到的数据全部锁住，事务结束再全部解锁，可以有效避免死锁，但是事务开始阶段并不清楚之后会用什么数据
- 两段锁：数据库一般使用两段锁协议
	- 加锁阶段：事务进入加锁阶段	
		- 对数据进行读操作，使用共享锁
		- 对数据进行写操作，使用排他锁
	- 解锁阶段：事务进入解锁阶段，该阶段不能再进行加锁操作


#### RC & RR
	
在不可重复读阶段，MySQL会在涉及对数据进行修改的数据行，加上排它锁，但是若只是读操作，不会上锁，这是在竞争条件下出现读到不同数据的主要原因。

- 如果数据SQL语句条件筛选中含有索引字段，会在索引行加上行锁
- 反之，MySQL会对整个表加上行锁，实际上，MySQL会过滤掉不符合条件的行，进行解锁（违反两段锁协议）。这样做目的是只有满足条件的数据行会被加上锁，但是每条记录上锁解锁的操作还是不可避免。

上述的情况，同样适用于MySQL的默认隔离级别RR（可重复读阶段）。所以，如果无法使用相应的索引进行大批量的更新操作，效率是十分低下的。

不可重复读的着重点在于update和delete，而幻读的着重点在于insert。

如果使用锁来实现两者隔离级别，在幻读阶段，sql在第一次取这些数据之后，就将这些数据加锁，其他事务无法修改，就可以实现可重复读了。但是这种方法无法锁住insert的数据，在竞争条件下，某事务可能就会发现多了一些之前没有的数据，这就是造成幻读的原因。可以使用串行隔离级别，读用读锁，写用写锁，读写和写写互斥，可以避免脏读、不可重复读和幻读，但是会极大降低数据库的并发。

这里使用的是悲观锁来进行操作，处于性能的考虑，MySQL使用MVVC来避免这两种问题。
	

#### MVVC & Next-Key锁

在MySQL中的读和事务隔离级别中的读，是不一样的。

在RR级别中，通过MVVC机制，虽然让数据变得可重复读，但是我们读到的可能是历史数据，不是数据库当前的最新数据！！！对于这种读取历史数据的方式，我们称之为"快照读"，而读取数据库当前版本数据的方式，叫"当前读"。

- 快照读：就是SELECT
	- SELECT * FROM table ...;
- 当前读：特殊的读操作，带有更新字段的操作，需要加锁，相当于写操作
	- SELECT * FROM table WHERE ? lock in share mode;
	- SELECT * FROM table WHREE ? for update;
	- INSERT;
	- UPDATE;
	- DELETE;
	
事务的隔离级别实际上都定义了当前读的级别，MySQL为了提高减少锁的处理（包括等待锁的释放），引入了快照读，使用快照读不需要加锁。而update和insert这些"当前读"的写操作，就需要另外的模块来解决。

为了解决当前读中的"幻读"问题，MySQL事务使用了Next-Key锁。NextKey锁是行锁（MVVC）和GAP（间隙锁）的合并。

比如在RR级别中，事务A在update写操作之后会加锁，导致事务B无法进行插入新数据，除非事务A提交后，这样事务A在update操作前后读的数据保持一致，避免了幻读，这就是GAP锁。

如下图：InnoDB把这段数据分成几个区间（这里column是聚蔟索引，column是二级索引）：

- (negative infitiny, 5]
- (5, 30]
- (30, positive infitiny)

这样，在column=30的数据加上行锁，在区间(5, 30和[30, positive infitiny)加上了间隙锁。

![](http://owj98yrme.bkt.clouddn.com/sql9.png)
	
如果使用的是没有的索引的字段，即使没有匹配到任何字段，那么会给全表加上GAP锁，除非该事务提交，否则其它事务无法插入任何数据。
它不能像行锁一样，自动过滤掉不符合条件的数据行，因为没有索引，那么这些字段就没有排序，也就没有区间。
	
行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和间隙锁组成的Next-Key锁共同解决了RR级别在写数据时的幻读问题。
	
## InnoDB   

- InnoDB是MySQL的默认事务型引擎，只有在需要InnnoDB不支持的特性时，才考虑其他存储引擎。
- 采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读。
- 表是基于聚蔟索引建立的，它对主键的查询性能有很高的提升。
- 内部做了很多优化，包括从磁盘读取数据时采用的可预测性，能够自动在内存中建立hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。
- 通过一些机制和机制支持真正的热备份。

## MyISAM

- MyISAM不支持事务和行级锁，而且奔溃后无法安全恢复。
- 只能对整张表加锁，而不是针对行。
- MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。
- 如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表适合采用 MyISAM 压缩表。
- 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机奔溃时会造成索引损坏，需要执行修复操作。


## InnoDB和MyISAM的区别

- 事务（InnoDB）
- 外键（InnoDB）
- 行锁（InnoDB）
- 聚蔟索引（主键索引----索引和文件绑在一起，辅助索引需要两次查询，先查询主键，再通过主键查到数据，主键不宜过大；主键索引和辅助索引相对独立）
- 全文索引（MyISAM，查询效率更高）
- 读多写少（MyISAM）


## 数据库三范式

## 分库分表

