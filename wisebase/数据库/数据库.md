# 数据库

## 事务

事务由一个或多个sql语句组成一个整体，如果所有的语句执行成功那么修改将会全部生效，如有一条语句失败，那么该事务被成功执行的sql语句会被撤销，只有在该事务中所有的语句全部执行成功的情况下，修改的数据才会被提交到数据库。

#### 事务的特性：ACID

- 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

- 一致性（Consistency）：一个事务执行之前和执行之后都必须处于一致性状态。比如，假设账户A和账户B两者一共有100块，不管A和B之间如何转账，转账几次，事务结束之后两个用户的钱相加起来应该还的是100。能量守恒定律。

- 隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，某个事务不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

- 持久性（Durability）：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。MySQL中会保存有相应的操作日志，即使遭遇故障依然能够通过日志回复最后一次更新。

#### 隔离级别

用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离别一般是支持更高的并发处理，并拥有更低的系统开销。

- Read Uncommitted（脏读）
读取未提交的数据，也被称为脏读。所有的事务都可以看到其它未提交事务的执行的结果。很少用于实际应用。事务A查询X的值未返回之前，事务B修改了X，事务A获得了非最新的实际值。

![s](http://p5s0bbd0l.bkt.clouddn.com/sql7.png) 

- Read Committed（不可重复读）
读取提交内容，满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。这种隔离级别也支持所谓的不可重复读，因为同一个事务的其他实例在该实例处理期间可能会有新的Commit，所以同一个select可能返回不同的结果。比如，事务A的两次查询X之间，事务B更新了X的值，那么事务A的两次查询结果将会不同。

![](http://p5s0bbd0l.bkt.clouddn.com/sql6.png) 

- Repeatable Read（幻读）
MySQL默认事务隔离级别，它确保同一个事务的多个实例在并发读取数据的时候，会看到同样数据行。产生了一个棘手的问题：幻读。幻读是指当事务不是独立执行时发生的一种现象。比如，事务A修改了全表的数据行，同时事务B向表插入新一行数据。那么以后处理事务A的用户发现表中还有未修改的数据行。
通过存储引擎的多版本并发控制间隙锁机制解决了该问题。**多版本并发控制只是解决了不可重复读的问题，而加上间隙锁（控制并发控制）才解决了幻读**。

![](http://p5s0bbd0l.bkt.clouddn.com/sql8.png) 

- Seriablizable（串行）
在每个读的数据行上加上共享锁，在这个最高级别的隔离级别上，可能导致大量的超时现象和锁竞争。

## InnoDB事务隔离级别

#### RC & RR
	
在不可重复读阶段，MySQL会在涉及对数据进行修改的数据行，加上排它锁，但是若只是读操作，不会上锁，这是在竞争条件下出现读到不同数据的主要原因。

- 如果数据SQL语句条件筛选中含有索引字段，会在索引行加上行锁
- 反之，MySQL会对整个表加上行锁，实际上，MySQL会过滤掉不符合条件的行，进行解锁（违反两段锁协议）。这样做目的是只有满足条件的数据行会被加上锁，但是每条记录上锁解锁的操作还是不可避免。

上述的情况，同样适用于MySQL的默认隔离级别RR（可重复读阶段）。所以，如果无法使用相应的索引进行大批量的更新操作，效率是十分低下的。

不可重复读的着重点在于update和delete，而幻读的着重点在于insert。

如果使用锁来实现两者隔离级别，在幻读阶段，sql在第一次取这些数据之后，就将这些数据加锁，其他事务无法修改，就可以实现可重复读了。但是这种方法无法锁住insert的数据，在竞争条件下，某事务可能就会发现多了一些之前没有的数据，这就是造成幻读的原因。可以使用串行隔离级别，读用读锁，写用写锁，读写和写写互斥，可以避免脏读、不可重复读和幻读，但是会极大降低数据库的并发。

这里使用的是悲观锁来进行操作，处于性能的考虑，MySQL使用MVVC来避免这两种问题。
	

#### MVVC & Next-Key锁

在MySQL中的读和事务隔离级别中的读，是不一样的。

在RR级别中，通过MVVC机制，虽然让数据变得可重复读，但是我们读到的可能是历史数据，不是数据库当前的最新数据！！！对于这种读取历史数据的方式，我们称之为"快照读"，而读取数据库当前版本数据的方式，叫"当前读"。

- 快照读：就是SELECT
	- SELECT * FROM table ...;
- 当前读：特殊的读操作，带有更新字段的操作，需要加锁，相当于写操作
	- SELECT * FROM table WHERE ? lock in share mode;
	- SELECT * FROM table WHREE ? for update;
	- INSERT;
	- UPDATE;
	- DELETE;
	
事务的隔离级别实际上都定义了当前读的级别，MySQL为了提高减少锁的处理（包括等待锁的释放），引入了快照读，使用快照读不需要加锁。而update和insert这些"当前读"的写操作，就需要另外的模块来解决。

为了解决当前读中的"幻读"问题，MySQL事务使用了Next-Key锁。NextKey锁是行锁（MVVC）和GAP（间隙锁）的合并。

比如在RR级别中，事务A在update写操作之后会加锁，导致事务B无法进行插入新数据，除非事务A提交后，这样事务A在update操作前后读的数据保持一致，避免了幻读，这就是GAP锁。

如下图：InnoDB把这段数据分成几个区间（这里column是聚蔟索引，column是二级索引）：

- (negative infitiny, 5]
- (5, 30]
- (30, positive infitiny)

这样，在column=30的数据加上行锁，在区间(5, 30和[30, positive infitiny)加上了间隙锁。

![](http://owj98yrme.bkt.clouddn.com/sql9.png)
	
如果使用的是没有的索引的字段，即使没有匹配到任何字段，那么会给全表加上GAP锁，除非该事务提交，否则其它事务无法插入任何数据。
它不能像行锁一样，自动过滤掉不符合条件的数据行，因为没有索引，那么这些字段就没有排序，也就没有区间。
	
行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和间隙锁组成的Next-Key锁共同解决了RR级别在写数据时的幻读问题。
	
## InnoDB   

- InnoDB是MySQL的默认事务型引擎，只有在需要InnnoDB不支持的特性时，才考虑其他存储引擎。
- 采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读。
- 表是基于聚蔟索引建立的，它对主键的查询性能有很高的提升。
- 内部做了很多优化，包括从磁盘读取数据时采用的可预测性，能够自动在内存中建立hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。
- 通过一些机制和机制支持真正的热备份。

## MyISAM

- MyISAM不支持事务和行级锁，而且奔溃后无法安全恢复。
- 只能对整张表加锁，而不是针对行。
- MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。
- 如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表适合采用 MyISAM 压缩表。
- 如果指定了 DELAY\_KEY\_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机奔溃时会造成索引损坏，需要执行修复操作。

## InnoDB和MyISAM的区别

- 事务（InnoDB）
- 外键（InnoDB）
- 行锁（InnoDB）
- 聚蔟索引（主键索引----索引和文件绑在一起，辅助索引需要两次查询，先查询主键，再通过主键查到数据，主键不宜过大；主键索引和辅助索引相对独立）
- 全文索引（MyISAM，查询效率更高）
- 读多写少（MyISAM）

## 数据库封锁协议

封锁能保证正确调度并发操作。为此，在运用写锁锁和读锁这两种基本封锁加锁时，还要约定规则，如何时加锁，持续时间，何时释放等，一般称这些规则为封锁协议。

```
封锁的相容矩阵
T	X	S	-
X	N	N	Y
S	N	Y	Y
-	Y	Y	Y

```

**一级封锁协议：**事务T要修改数据A时必须加写锁，直到**事务T结束**才释放写锁。一级封锁协议不能解决脏读的问题，根据封锁相容矩阵，加了写锁和没加锁是相容的。所以事务T2可以在T1没有释放写锁的时候读到脏数据。

**二级封锁协议：**在一级封锁协议基础上，要求读取数据A时必须加上读锁，读取完马上释放读锁。由于S锁和X锁不兼容原理，所以解决脏读问题。由于写锁的事务发生时间可能发生于事务T的两次读锁的中间，所以有不可重复读的问题。

**三级封锁协议：**在二级封锁协议基础上，要求读取数据A时必须加上读锁，直到**事务T结束**才释放读锁。二级封锁协议解决了不可重复读的问题，但是仍然存在幻读的问题。


**两段锁协议：**会出现死锁的情况。

- 加锁阶段：在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁
- 解锁阶段：在释放一个封锁之后，事务不再申请和获得其它任何封锁


**一次封锁法：**一次封锁法要求所有事务必须一次性将所有要使用的数据全部加锁，否则就不能继续执行。因此一次封锁法遵守两段锁协议，但两段锁协议并不要求所有事务必须一次性将所有要使用的数据进行加锁，这就是两段锁协议可能发生死锁的原因所在。




## 数据库范式

**第一范式：**确保每列保持原子性（所有字段值都是不可分解的原子值）。比如一个地址有省份、城市、城镇等详细可分的位置是不符合第一范式。

**第二范式：**确保表中每列都和主键相关（不要把多种不相关的数据存在同一张表中）。比如设计订单信息表，而订单中有多种不同的商品，需要把订单和商品作为表的联合主键，否则就是不符合第二范式。

**第三范式：**确保每列都和主键直接相关，而不是间接相关。比如在订单信息表中，可以将客户编号作为一个外键和订单表建立直接的相关关系，而不可以在订单表中间添加关于客户的其它字段。

**第四范式：**要求把同一个表内的多对多关系删除。

**第五范式：**从最终结构建立原始结构。

**BCNF**：符合第三范式，并且消除主属性对其他主属性的传递依赖。

## 分库分表

两种分法：水平（横向切分）和垂直（纵向）切分


#### 水平切分

根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表只包含一部分数据，从而使得单个表的数据量变小，达到分布的效果。（比如按照某个字段的大小、或者某个字段的哈希分片处理）。

**水平切分的优点：**

- 不存在单库单表数据量过大、高并发的性能瓶颈，提高系统的稳定性和负载能力
- 应用端改造较小，不需要拆分业务模块。


**水平切分的缺点：**

- 跨库跨表的事务一致性难以保证
- 跨库的join关联查询性能较差
- 数据多次扩展难度和维护量极大

#### 垂直切分

垂直切分可以分为垂直分库和垂直分表两种。

垂直分库是根据业务耦合性，将关联度低的不同表存储在不同的数据库。

垂直分表是基于数据库中的字段进行切分，可以将不经常用或字段长度较大的字段拆分至扩展表中。


**垂直切分的优点：**

- 解决业务层面的耦合，使业务清晰
- 与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控和扩展等
- 高并发场景下，垂直切分能够一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈

**垂直切分的缺点：**

- 分布式事务处理复杂
- 需要通过接口聚合不同表中的字段，提高开发难度
- 单表数据数据量过大的问题依然存在
