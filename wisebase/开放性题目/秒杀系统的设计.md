# 秒杀系统的设计


- 秒杀系统为什么难做？

主要原因：库存只有一个，所有的人都会在集中的时间点，进行读写操作。
比如：小米手机的抢购，12306的春节抢票，库存与瞬时进入的几百几千万流量不成正比。

- 流量到是亿级别，常见站点架构如下：
	- 浏览器端：最上层，执行一些JS代码
	- 站点层：访问后端数据，拼成HTML页面返回给浏览器
	- 服务器层：向上游屏蔽底层数据细节
	- 数据层：最终的库存是存在这里的，比如MySQL
	
- 优化的方向点：
	- 将请求尽量拦截在系统上游，传统秒杀系统的问题：请求会压倒后端数据层，数据读写锁冲突严重，并发高，响应慢，几乎所有的请求都超时，写成功的有效请求很小。
	- 充分利用缓存：典型的读多写少，十分适合用缓存来处理
	
- 优化细节
	- 浏览器层请求拦截：
	利用JS代码限制x秒内只能提交一次请求，可以让“查询”或者“购买”按钮置灰，x秒后恢复
	- 站点层请求拦截与页面缓存：
		- 同一个userId限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一个页面
		- 用一个itemId的查询，x秒内到达站点层的请求，均返回同一个页面
	- 服务层请求拦截与数据缓存：
		- 读请求：使用Redis缓存抗，单机扛个每秒/10W次请求没有什么问题
		- 写请求：由于库存有限，不可坑让所有的写请求访问，使用写请求队列，每次只透有限的写请求去数据层，直到库存耗尽
	- 数据层：
	到了数据层比如MySQL，几乎就没有什么请求了，单机也可以抗得住，再次强调，库存是有限的，没有必要让那么多请求来访问数据层

- 总结
	- 尽量将请求拦截在系统上游
	- 读多写少的系统多使用缓存